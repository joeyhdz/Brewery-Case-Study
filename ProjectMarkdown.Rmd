---
title: "project 1 markdown"
author: "Joey Hernandez, and Robert Blue"
date: "2022-10-18"
output: html_document
---
## Introduction:
#### Thank you Mr.Smith, and Mr. Jones for the opportunity for us to deliver Beer and Brewery insights so that your company Booze and Brews can align it's strategic plan for growth, and offerings so that you can maximize revenues and grow your presence.

First, we will being by loading all packages and data that we will need to investigate and present findings of beer and breweries:
```{r}
library(tidyverse)
library(ggplot2)
library(janitor)
library(usmap)
library(caret)
library(e1071)
library(class)
beer_data <-read.csv("C:/Users/Joey/Desktop/DDS_Work/Unit - 8/Beers.csv")
brew_data <- read.csv("C:/Users/Joey/Desktop/DDS_Work/Unit - 8/Breweries.csv")
```

## Data at a glance & Missing Vaules


#### During our initial consultation, you mentioned the data could contain some missing values as well as some potential errors. In order for us to present the most accurate findings, we took a series of steps to ensure that any errors or missing values were either addressed or corrected.

##### 1.  Identify the rows and columns of the data sets. This first glance allows us to understand what type of variables and variable types we are working with, additionally, we are able to understand the size of data that we have.

##### 2.  Viewing the datasets allowed us to identify similar columns within the 2 groups that we could use to merge the data. Merging the data together allows us to create a dataframe that contains all we need in one location. We will not yet merge the data within this step but we do take action and rename any columns that may be of intrest. What you will find if you look at the data is that we changed both data brewery identification columns to the title 'Brewery_id' so that we could merge the data with this as our bridge variable.


##### 3.  Before merging the data together we checked each dataset individually for missing values and broke them into explicit and implicit missing values.


##### 4.  We addressed Explicit Values (NAs) by investigating why there may have been expliciltly missing values in the data. Upon further investigation we discovered that certain values are not always reported (or are required to be reported) by breweries. This varies from brewery to brewery but most often has to do with state and other governing matters. In the case of missing IBU values this also varies from location to location and can be attributed to differnent crafting methods in addition to simply not being required to report. We did not completely leave out this data, but instead left it as NA when applicaple since it represented such a high amount of data.


##### 5.  The data did contain some Implicit values in the form of missing data. Upon futher investigation we were able to either remedy the missing values by researching the product in question, or gain an understanding of why a value may not have been present so that we could understand how it would impact the remaning data (or if it impacted the remaining data).


##### 6.  There was instances of duplicate data which were attributed to incorrect brewery locations, or were attributed to repeated batches of an offering as well as different sizes of certain drinks. The remedy was addressed on a case by case basis, but in short the only data removed was data that was incorrect, such as the duplicate locations entered by spelling, or typo errors. 


##### 7.  While not a big issue, the state abbreviations all contained some white space before the actual charater of the string. This white space was removed to better utilize the variable.


##### 8. Finally after all found errors were addressed, we merged the data into one piece.

```{r}
#################### Exploring Raw Data ###########################
# check rows and columns
head(beer_data)
head(brew_data)

# rename columns for merging 
names(beer_data)[1] <- 'beer_name'
names(brew_data)[2] <- 'Brew_name'
names(brew_data)[1]<- 'Brewery_id'


# checking for missing values beer 
sapply(beer_data,function(x) sum(is.na(x))/nrow(beer_data))
sapply(beer_data,function(x) sum(x== ""))

# checking for missing values brew
sapply(brew_data,function(x) sum(is.na(x))/nrow(brew_data))
sapply(brew_data,function(x) sum(x== ""))

# addressing the missing values from beer
beer_data[854,'Style'] = "Scottish Ale"
beer_data[867, 'Style'] = 'Marzen'



# looking for duplicates in data 
brew_data %>% get_dupes(Brewery_id)
brew_data %>% get_dupes(Brew_name)
beer_data %>% get_dupes(beer_name)
beer_data %>% get_dupes(Brewery_id)
beer_data %>% get_dupes(Beer_ID)

# addresses the duplicates in brew_data 
brew_data<- brew_data[-c(96,378,262,139),] 

# addresses the duplicates in beer_data
beer <- beer_data[!duplicated(beer_data$beer_name),]
beer %>% get_dupes(Brewery_id) # these duplicates are for various drinks from the same brew id
beer %>% get_dupes(Beer_ID) # fixed
beer %>% get_dupes(beer_name)

# gets rid of the white space before the State abb. 
brew_data$State<-trimws(brew_data$State, "left")


# merging beer and brew_data - with an inner join
beer_brew <- merge(brew_data, beer, by ='Brewery_id')


```
################################### code for later ##################################

state_brew <- na.omit(master_data)
state_brew %>% get_dupes(Brew_name)
unique(state_brew)


casestudy <- na.omit(casestudy) # to omit NA values.

# for creating a table in RMD
#kable(casestudy %>% group_by(State) %>%
#summarise(n_unique = n_distinct(Brew_name),
#mean_abv = mean(abv), mean_ibu = mean(ibu)) %>%
#arrange(desc(n_unique)))


################################### Question 1 ##################################

# this gets only one brewery name so that we don't have multiple brew representation because 
# of the multiple drinks served by that one location. 
state_num_data <- beer_brew[!duplicated(beer_brew$Brew_name),]

# the n_distinct takes care of the potential repeat brew representation making last line redundant
# but kept in as precautionary measure.
state_brew_plot <- state_num_data %>% group_by(State) %>%
  summarise(num_brew = n_distinct(Brew_name),
  mean_abv = mean(ABV), mean_ibu = mean(IBU)) %>%
  arrange(desc(num_brew))

state_brew_plot

# changes column State to state to satisfy the usmap argument
names(state_brew_plot)[1] <- 'state'

# makes into dataframe
state_brew_plot <- as.data.frame(state_brew_plot)

# plot of the Concentration of Breweries in the US
plot_usmap(data=state_brew_plot[,1:2],
           regions = "states",
           labels = TRUE,label_color = "black",
           values = "num_brew") +
          scale_fill_gradient(low = 'white', high = 'red')+
          labs(title = 'Distribution of Breweries across the United States',
               fill = "Brewery \nAmount") +
          theme(legend.position = "right") 
    

################################### Question 3 ##################################
################################### Question 4 ##################################

# this will return medians for each state ( NA NOT INCLUDED )
state_medians <- beer_brew %>% group_by(State) %>%
  summarise(num_brew = n_distinct(Brew_name),
            median_abv = median(ABV, na.rm = TRUE), median_ibu = median(IBU, na.rm = TRUE)) %>%
  arrange(desc(num_brew))

# to return the medians data
state_medians

# convert to data frame
state_medians <- as.data.frame(state_medians)

# plot Median ABV
state_medians %>% ggplot(aes(x = reorder(State, desc(median_abv)), y = median_abv, fill = State))+
  geom_bar(stat='identity')+
  coord_flip()

# plot Median IBU
state_medians %>% ggplot(aes(x = reorder(State, desc(median_ibu)), y = median_ibu, fill = State))+
  geom_bar(stat = 'identity') +
  coord_flip()


################################### Question 5 ##################################
# this is not very helpful... 
# plot for ABV
max_abv <- beer_brew %>% select(ABV, State)

max_abv %>% ggplot(aes(ABV, fill = State)) +
  geom_bar(stat = 'count')+
  coord_flip()

max_abv %>% ggplot(aes(ABV, color = State)) + 
  geom_point(stat = 'count')

# plot for IBU
max_ibu <- beer_brew %>% select(IBU, State)

max_ibu %>% ggplot(aes(IBU, fill = State)) +
  geom_bar(stat = 'count')+
  coord_flip()
################################### Question 6 ##################################

abv_dis_plot <- beer_brew %>% select(ABV,Style)
abv_dis_plot %>% ggplot(aes(ABV)) +
  geom_histogram(color = 'black',aes(fill = 'red'), alpha = .5, show.legend = FALSE) +
  ggtitle('Distribution of the Alcohol by Volume Content in Beer From Various Breweries')+
  ylab('Frequency') + xlab('Alcohol by Volume')

################################### Question 7 ##################################

ibu_abv_plot <- beer_brew %>% select(IBU,ABV,Style)

ibu_abv_plot %>% ggplot(aes(x = ABV, y = Style)) +
  geom_point(aes(color = 'red'), position = "identity") +
  geom_point(aes(IBU, Style), color='blue')

ibu_abv_plot %>% ggplot(aes(x = ABV, y = IBU))+
  geom_point()+
  geom_smooth(se=FALSE)
             



################################### KNN Prediction Model Data #########################

# test to see how the model will work using beer_brew

# make a Dataframe without NA so that we can run KNN:
beer_predict <- na.omit(beer_brew)
# sanity check 
#view(beer_predict)

# simple test to see if the data works together within the KNN function
my_beer_test <- data.frame(IBU = c(.05, .04, .043), ABV = c(.06, .055, .065))
knn(beer_predict[,c(7,8)], my_beer_test, beer_predict$Style, k = 3, prob = TRUE)


# viewing what matches each of these strings will return before filtering. 
(str_view_all(beer_predict$Style, 'Ale', match = TRUE))
(str_view_all(beer_predict$Style, 'IPA', match = TRUE))

# creating test variable to call so we can see if the filter works
#test_ale_filter <- beer_predict %>% filter(str_detect(Style, 'Ale'))
#view(test_ale_filter$Style) # viewing the filter for effectiveness

# repeating the same process for the IPA
#test_ipa_filter <- beer_predict %>% filter(str_detect(Style, 'IPA'))
#view(test_ipa_filter$Style) # viewing the filter for effectiveness 

# using both filters above to create one combo test filter
#test_combo_filter<- beer_predict %>% filter(str_detect(Style, 'IPA') | str_detect(Style, "Ale"))
#view(test_combo_filter$Style)


# creating the finalized data frame to use for test/train split etc. 
beer_predict_fin <- beer_predict %>% filter(str_detect(Style, 'IPA') | str_detect(Style, "Ale"))
glimpse(beer_predict_fin)

################################### KNN Test Train Split & initial run #########################

#checking dimensions to understand what our test/train will look like
glimpse(beer_predict_fin)
(nrow(beer_predict_fin)) # total 887 rows
(round(nrow(beer_predict_fin)*.3)) # total 177


set.seed(765)
intrain <- sample(nrow(beer_predict_fin), round(nrow(beer_predict_fin)*.30))
beer_train <- beer_predict_fin[intrain,]
beer_test <- beer_predict_fin[-intrain,]

# setting up the classification 
classification <- knn(beer_train[,c(7,8)],
                      beer_test[,c(7,8)],
                      beer_train$Style,
                      k = 3, prob = TRUE)

# setting up a passable data for confusion matrix 
u <- union(classification, beer_test$Style)
t <- table(factor(classification, u), factor(beer_test$Style, u))

# confusion matrix for more stats on the model
confusionMatrix(t)


################################### KNN finding best K #########################

iterations = 50
num_of_k = 50
split_percent = .3

model_accuracy = matrix(nrow = iterations, ncol = num_of_k)
model_specificity = matrix(nrow = iterations, ncol = num_of_k)
model_sensitivity = matrix(nrow = iterations, ncol = num_of_k)

for (j in 1:iterations)
{
  set.seed(765)
  intrain2 <- sample(nrow(beer_predict_fin), round(nrow(beer_predict_fin)*split_percent))
  train2 <- beer_predict_fin[intrain2,]
  test2 <- beer_predict_fin[-intrain2,]
  for(i in 1:num_of_k)
  {
    classify = knn(train2[,c(7,8)],
                   test2[,c(7,8)],
                   train2$Style,
                   k = i, prob = TRUE)
    u = union(classify, test2$Style)
    t = table(factor(classify, u), factor(test2$Style, u))
    CM = confusionMatrix(t)
    model_accuracy[j,i] = CM$overall[1]
    model_specificity[j,i] = CM$byClass[1]
    model_sensitivity[j,i] = CM$byClass[2]
  }
  
  
}
CM
mean_accuracy = colMeans(model_accuracy)
mean_specificity = colMeans(model_specificity)
mean_sensitivity = colMeans(model_sensitivity)

plot(seq(1,num_of_k,1),
     mean_accuracy, type = "l",
     xlab = "Kth value 1:50",
     ylab = "Mean value of measured Accuracy")

plot(seq(1, num_of_k, 1),
     mean_specificity,
     type = 'l',
     xlab = "Kth value 1:50",
     ylab = "Mean value of measured Specifity")

plot(seq(1, num_of_k, 1),
     mean_sensitivity, type = 'l',
     xlab = "Kth value 1:50",
     ylab = "Mean value of measured Sensitivity")
